<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>–° –¥–Ω—ë–º —Ä–æ–∂–¥–µ–Ω–∏—è!</title>
  <style>
    :root{
      --bg:#0f0f13;
      --fg:#e9e9ee;
      --muted:#b7b7c2;
      --accent:#ff6fa9;
      --accent-2:#ffc1d9;
    }
    *{box-sizing:border-box}
    html,body{height:100%;margin:0}
    body{font-family: system-ui, -apple-system, Segoe UI, Roboto, "Inter", Arial, sans-serif; background: radial-gradient(1200px 800px at 50% 20%, #1a1a22, var(--bg)); color:var(--fg); overflow-x:hidden}
    .wrap{min-height:100vh; display:flex; flex-direction:column; align-items:center;}

    /* Stage area */
    .stage{position:relative; width:100%; height:60vh; max-height:720px; overflow:hidden}
    canvas#petals{position:absolute; inset:0; width:100%; height:100%; display:block}

    .title-overlay{display:none !important}
    .fade-in{animation:fadeIn .9s ease forwards}
    @keyframes fadeIn{from{opacity:0; transform:translateY(6px)} to{opacity:1; transform:none}}

    /* Prompt / input */
    .panel{width:min(720px, 92vw); margin:24px auto 16px; padding:18px 20px; background:#16161d; border:1px solid #242433; border-radius:16px; box-shadow:0 10px 30px rgba(0,0,0,.35)}
    .panel h2{margin:0 0 10px; font-size:18px; font-weight:600; color:var(--fg)}
    .panel p{margin:0 0 14px; color:var(--muted)}
    .row{display:flex; gap:10px}
    input[type="text"]{flex:1; padding:12px 14px; border-radius:12px; border:1px solid #2a2a3b; background:#0d0d12; color:var(--fg); font-size:16px}
    input[type="text"]::placeholder{color:#6a6a79}
    button{padding:12px 16px; border-radius:12px; border:1px solid #2a2a3b; background:linear-gradient(180deg, #1f1f29, #171720); color:var(--fg); cursor:pointer; font-weight:600}
    button:hover{filter:brightness(1.1)}

    .hint{margin-top:8px; font-size:13px; color:#8b8b98}

    /* Second screen */
    .screen{display:none; min-height:100vh; align-items:center; justify-content:center; padding:40px 20px}
    .screen.active{display:flex}
    .card{width:min(820px,95vw); background:#16161d; border:1px solid #242433; border-radius:18px; padding:36px; text-align:center; box-shadow:0 12px 36px rgba(0,0,0,.4)}
    .card h1{font-size:28px; margin:0 0 10px}
    .card p{font-size:18px; color:var(--muted)}

    /* Audio button */
    .audio-ctrl{position:fixed; right:16px; bottom:16px; display:flex; gap:10px}
    .tag{display:inline-flex; align-items:center; gap:8px; padding:8px 12px; border-radius:999px; border:1px solid #2a2a3b; background:#14141b; color:#cfcfde; font-size:12px}
    .dot{width:8px;height:8px;border-radius:50%;background:#e05a9b; box-shadow:0 0 10px #e05a9b88}

    .foot{opacity:.6; font-size:12px; text-align:center; margin:20px 0 30px}
    a{color:var(--accent)}
  </style>
</head>
<body>
  <div class="wrap">
    <div class="stage" id="stage">
      <canvas id="petals"></canvas>
      <!-- Optional overlay text while forming -->
      <div id="overlayText" class="title-overlay" aria-hidden="true"></div>
    </div>

    <div class="panel" id="panel" aria-live="polite">
      <h2>–Ω–∞–ø–æ–º–Ω–∏, –∫—Ç–æ –æ—Ç–ø—Ä–∞–≤–∏–ª —Ç–µ–±–µ —ç—Ç–æ?</h2>
      <p>–ü–æ–¥—Å–∫–∞–∑–∫–∞: —ç—Ç–æ –æ–¥–Ω–∞-–µ–¥–∏–Ω—Å—Ç–≤–µ–Ω–Ω–∞—è —Ñ—Ä–∞–∑–∞, –ø–æ–¥ –∫–æ—Ç–æ—Ä–æ–π –æ–Ω —É —Ç–µ–±—è —Å–æ—Ö—Ä–∞–Ω—ë–Ω üôÇ</p>
      <form class="row" id="answerForm">
        <input id="answer" type="text" placeholder="–≤–≤–µ–¥–∏ —Ñ—Ä–∞–∑—É" autocomplete="off" maxlength="64" />
        <button type="submit" title="–ü—Ä–æ–≤–µ—Ä–∏—Ç—å">–û–∫</button>
      </form>
      <div class="hint">–ù–µ–±–æ–ª—å—à–æ–π –Ω–∞–º—ë–∫: –∞–Ω–≥–ª–∏–π—Å–∫–∏–π, —Ç—Ä–∏ —Å–ª–æ–≤–∞.</div>
    </div>

    <div class="foot">–°–¥–µ–ª–∞–Ω–æ —Å –ª—é–±–æ–≤—å—é –±—Ä–∞—Ç–æ–º üíú</div>
  </div>

  <!-- Success screen -->
  <section class="screen" id="screen2">
    <div class="card fade-in">
      <h1>–í–µ—Ä–Ω–æ! üéâ</h1>
      <p>–Ø –ø—Ä–æ—Å—Ç–æ —Ö–æ—Ç–µ–ª —Å–∫–∞–∑–∞—Ç—å, —á—Ç–æ —Ç—ã –≤—Å–µ–≥–¥–∞ –±—ã–ª–∞ —Å–≤–µ—Ç–æ–º, –¥–∞–∂–µ –∫–æ–≥–¥–∞ –¥–µ–Ω—å –ø–∞—Å–º—É—Ä–Ω—ã–π ‚ù§Ô∏è</p>
      <div style="margin-top:18px">
        <button id="restartBtn">–ï—â—ë —Ä–∞–∑</button>
      </div>
    </div>
  </section>

  <!-- Background music (provide your own lofi.mp3 or keep off) -->
  <audio id="bgm" preload="auto" loop>
    <!--
      üíø –ü–æ–ª–æ–∂–∏ —Ä—è–¥–æ–º —Å index.html —Ñ–∞–π–ª lofi.mp3 (–∏–ª–∏ —É–∫–∞–∂–∏ –∞–±—Å–æ–ª—é—Ç–Ω—É—é —Å—Å—ã–ª–∫—É –Ω–∞ –ª—é–±–∏–º—ã–π —Ç—Ä–µ–∫),
      –Ω–∞–ø—Ä–∏–º–µ—Ä –æ—Ç—Ç—É–¥–∞, –≥–¥–µ –ª–µ–≥–∞–ª—å–Ω–æ —Ä–∞–∑—Ä–µ—à–µ–Ω–æ —Ä–∞—Å–ø—Ä–æ—Å—Ç—Ä–∞–Ω–µ–Ω–∏–µ.
      –ü—Ä–∏–º–µ—Ä (–∑–∞–º–µ–Ω–∏ src –Ω–∏–∂–µ):
      <source src="https://cdn.pixabay.com/download/audio/2023/02/22/audio_6f4b6b.mp3?filename=lofi-study-140150.mp3" type="audio/mpeg" />
    -->
  </audio>

  <div class="audio-ctrl">
    <span class="tag" id="musicState"><span class="dot"></span> –º—É–∑—ã–∫–∞: –≤—ã–∫–ª</span>
    <button id="musicBtn" title="–í–∫–ª—é—á–∏—Ç—å –º—É–∑—ã–∫—É">–í–∫–ª—é—á–∏—Ç—å –º—É–∑—ã–∫—É</button>
  </div>

  <script>
  ;(() => {
    const CANVAS = document.getElementById('petals');
    const CTX = CANVAS.getContext('2d');
    const OVERLAY = document.getElementById('overlayText');
    const PANEL = document.getElementById('panel');
    const SCREEN2 = document.getElementById('screen2');
    const ANSWER = document.getElementById('answer');
    const FORM = document.getElementById('answerForm');
    const MUSIC_BTN = document.getElementById('musicBtn');
    const MUSIC_STATE = document.getElementById('musicState');
    const BGM = document.getElementById('bgm');
    const RESTART = document.getElementById('restartBtn');

    const TARGET_TEXT = '–° –¥–Ω—ë–º —Ä–æ–∂–¥–µ–Ω–∏—è!';
    const stage = document.getElementById('stage');

    // Resize canvas
    function fit() {
      const dpr = Math.min(window.devicePixelRatio || 1, 2);
      CANVAS.width = Math.floor(stage.clientWidth * dpr);
      CANVAS.height = Math.floor(stage.clientHeight * dpr);
      CANVAS.style.width = stage.clientWidth + 'px';
      CANVAS.style.height = stage.clientHeight + 'px';
      CTX.setTransform(dpr, 0, 0, dpr, 0, 0);
      buildTextTargets();
    }
    window.addEventListener('resize', fit);

    // Particles (petals)
    const petals = [];
    const MAX = Math.min(900, Math.ceil(stage.clientWidth*stage.clientHeight/2200));
    const palette = [ '#ffd1e0', '#ffc2da', '#ffb3d4', '#ffa3cd', '#ff94c7', '#ff86c1' ];

    function rand(a,b){return Math.random()*(b-a)+a}
    function pick(arr){return arr[(Math.random()*arr.length)|0]}

    function createPetal(yStart = rand(-stage.clientHeight, 0)){
      const size = rand(6, 16);
      return {
        x: rand(0, stage.clientWidth),
        y: yStart,
        vx: rand(-0.4, 0.4),
        vy: rand(0.6, 1.6),
        wobble: rand(0, Math.PI*2),
        wobbleSpeed: rand(0.01, 0.03),
        rot: rand(0, Math.PI*2),
        rotSpeed: rand(-0.02, 0.02),
        size,
        color: pick(palette),
        target: null,
        arriveT: 0
      }
    }

    for (let i=0;i<Math.min(MAX, Math.ceil(stage.clientWidth*stage.clientHeight/1600));i++) {
      petals.push(createPetal(rand(-stage.clientHeight, stage.clientHeight)));
    }

    // Draw a single petal as a soft rotated teardrop/ellipse
    function drawPetal(p) {
      const s = p.size;
      CTX.save();
      CTX.translate(p.x, p.y);
      CTX.rotate(p.rot + Math.sin(p.wobble)*0.2);
      const grad = CTX.createRadialGradient(0, 0, 1, 0, 0, s);
      grad.addColorStop(0, '#fff5f8');
      grad.addColorStop(1, p.color);
      CTX.fillStyle = grad;
      CTX.beginPath();
      // A simple leaf/petal-ish shape using bezier
      CTX.moveTo(0, -s*0.2);
      CTX.bezierCurveTo(s*0.9, -s*0.9,  s*0.9,  s*0.9, 0, s);
      CTX.bezierCurveTo(-s*0.9,  s*0.9, -s*0.9, -s*0.9, 0, -s*0.2);
      CTX.closePath();
      CTX.fill();
      CTX.restore();
    }

    // Text targets
    let targets = [];
    let forming = false;
    let formed = false;

    function buildTextTargets(){
      const w = stage.clientWidth;
      const h = stage.clientHeight;
      // render to a smaller offscreen canvas for cleaner sampling on mobile
      const scale = (w < 520 ? 0.45 : 0.6);
      const offW = Math.max(240, Math.floor(w*scale));
      const offH = Math.max(160, Math.floor(h*scale));
      const off = document.createElement('canvas');
      off.width = offW; off.height = offH;
      const c = off.getContext('2d');
      const fontSize = Math.max(26, Math.min(90, Math.floor(offW * 0.18)));
      c.fillStyle = '#ffffff';
      c.textAlign = 'center';
      c.textBaseline = 'middle';
      c.font = `900 ${fontSize}px system-ui, -apple-system, Segoe UI, Roboto, Arial`;
      c.clearRect(0,0,offW,offH);
      c.fillText(TARGET_TEXT, offW/2, offH/2);

      const img = c.getImageData(0,0,offW,offH).data;
      const step = (w < 520 ? 3 : 2); // sparser on phones
      const collected = [];
      for (let y = 0; y < offH; y += step) {
        for (let x = 0; x < offW; x += step) {
          const a = img[(y*offW + x)*4 + 3];
          if (a > 140) collected.push({x: Math.floor(x/scale), y: Math.floor(y/scale)});
        }
      }
      // limit number of targets for readability
      const maxTargets = (w < 520 ? 380 : 750);
      if (collected.length > maxTargets){
        const stride = Math.floor(collected.length / maxTargets);
        targets = collected.filter((_, i) => i % stride === 0).slice(0, maxTargets);
      } else {
        targets = collected;
      }
      // shuffle to avoid stripes
      for (let i=targets.length-1;i>0;i--){
        const j = (Math.random()* (i+1))|0; [targets[i], targets[j]] = [targets[j], targets[i]];
      }
    }px system-ui, -apple-system, Segoe UI, Roboto, Arial`;
      c.shadowColor = 'rgba(255,255,255,0.2)';
      c.shadowBlur = 0;
      c.clearRect(0,0,w,h);
      c.fillText(TARGET_TEXT, w/2, h/2);

      const step = Math.max(3, Math.floor((w*h)/300000)); // density control
      const img = c.getImageData(0,0,w,h).data;
      targets = [];
      for (let y = 0; y < h; y += step) {
        for (let x = 0; x < w; x += step) {
          const a = img[(y*w + x)*4 + 3];
          if (a > 150) targets.push({x, y});
        }
      }
      // shuffle to avoid obvious stripes
      for (let i=targets.length-1;i>0;i--){
        const j = (Math.random()* (i+1))|0; [targets[i], targets[j]] = [targets[j], targets[i]];
      }
    }

    function assignTargets(){
      const need = Math.min(petals.length, targets.length);
      // ensure enough petals to cover targets
      if (petals.length < targets.length){
        const toAdd = targets.length - petals.length;
        for (let i=0;i<toAdd;i++) petals.push(createPetal(rand(-stage.clientHeight, 0)));
      }
      for (let i=0;i<need;i++){
        const p = petals[i];
        p.target = targets[i];
        p.arriveT = 0;
      }
      forming = true;
    }
      forming = true;
    }

    // Animation loop
    let last = performance.now();
    function tick(t){
      const dt = Math.min(32, t - last); last = t;
      CTX.clearRect(0,0, stage.clientWidth, stage.clientHeight);

      // Spawn extra petals over time until MAX
      if (!forming && petals.length < MAX && Math.random() < 0.3) petals.push(createPetal());

      for (const p of petals){
        if (p.target && forming){
          // Ease towards the target with stronger attraction and snap near end
          const dx = p.target.x - p.x;
          const dy = p.target.y - p.y;
          const dist = Math.hypot(dx, dy);
          const k = 0.08; // attraction
          p.vx = (p.vx||0) * 0.85 + dx * k * 0.02;
          p.vy = (p.vy||0) * 0.85 + dy * k * 0.02;
          p.x += p.vx;
          p.y += p.vy;
          p.rot *= 0.98;
          p.wobble += p.wobbleSpeed * 0.3;
          if (dist < 1.2){ p.x = p.target.x; p.y = p.target.y; p.vx = p.vy = 0; p.arriveT += dt; }
        } else {
          // Falling
          p.wobble += p.wobbleSpeed;
          p.x += Math.sin(p.wobble)*0.4 + p.vx;
          p.y += p.vy;
          p.rot += p.rotSpeed;
          if (p.y > stage.clientHeight + 20) {
            // recycle to the top
            p.y = -20; p.x = rand(0, stage.clientWidth);
          }
        }
        drawPetal(p);
      }

      requestAnimationFrame(tick);
    }

    // Orchestrate timeline
    function orchestrate(){
      OVERLAY.textContent = '';
      formed = false; forming = false;
      // after a short moment, start forming into the phrase
      setTimeout(() => {
        assignTargets();
        // show overlay soft glow text as it forms (assist readability)
        // overlay disabled; just mark formed later
        setTimeout(()=>{ formed = true; }, 4500);
      }, 3200);
      // reveal the panel slightly later
      setTimeout(() => {
        PANEL.classList.add('fade-in');
      }, 5200);
    }

    // Answer logic
    function normalize(s){return (s||'').toLowerCase().trim().replace(/\s+/g,' ')}

    FORM.addEventListener('submit', (e) => {
      e.preventDefault();
      const ok = normalize(ANSWER.value) === 'what is love';
      if (ok){
        // transition to screen 2
        document.querySelector('.wrap').style.display = 'none';
        SCREEN2.classList.add('active');
      } else {
        ANSWER.style.borderColor = '#e05a9b';
        ANSWER.animate([
          { transform:'translateX(0)' },
          { transform:'translateX(-6px)' },
          { transform:'translateX(6px)' },
          { transform:'translateX(0)' }
        ], { duration:180, iterations:2 });
      }
    });

    RESTART?.addEventListener('click', () => {
      // reset
      SCREEN2.classList.remove('active');
      document.querySelector('.wrap').style.display = '';
      ANSWER.value='';
      ANSWER.style.borderColor='';
      petals.splice(0, petals.length);
      for (let i=0;i<Math.min(MAX, Math.ceil(stage.clientWidth*stage.clientHeight/1600));i++) {
        petals.push(createPetal(rand(-stage.clientHeight, stage.clientHeight)));
      }
      fit();
      orchestrate();
    });

    // Audio control (requires user gesture)
    let audioOn = false;
    async function toggleMusic(){
      try{
        if (!audioOn){
          if (BGM.src === '' && !BGM.querySelector('source')){
            // If no source provided, create a very soft WebAudio pad as fallback
            await startWebAudioLofi();
          } else {
            await BGM.play();
          }
          audioOn = true; MUSIC_STATE.innerHTML = '<span class="dot"></span> –º—É–∑—ã–∫–∞: –≤–∫–ª';
          MUSIC_BTN.textContent = '–í—ã–∫–ª—é—á–∏—Ç—å –º—É–∑—ã–∫—É';
        } else {
          if (audioCtx){ audioCtx.suspend(); }
          BGM.pause();
          audioOn = false; MUSIC_STATE.innerHTML = '<span class="dot"></span> –º—É–∑—ã–∫–∞: –≤—ã–∫–ª';
          MUSIC_BTN.textContent = '–í–∫–ª—é—á–∏—Ç—å –º—É–∑—ã–∫—É';
        }
      }catch(err){
        console.warn('Audio play blocked or failed:', err);
      }
    }
    MUSIC_BTN.addEventListener('click', toggleMusic);

    // Minimal WebAudio fallback: gentle lo-fi pad
    let audioCtx, gNodes=[];
    async function startWebAudioLofi(){
      if (audioCtx) { await audioCtx.resume(); return; }
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      const master = audioCtx.createGain(); master.gain.value = 0.05; master.connect(audioCtx.destination);

      function makePad(freq){
        const o = audioCtx.createOscillator();
        const g = audioCtx.createGain();
        o.type = 'sine';
        o.frequency.value = freq;
        g.gain.value = 0.0001;
        o.connect(g).connect(master);
        o.start();
        // slow breathing
        const now = audioCtx.currentTime;
        g.gain.cancelScheduledValues(now);
        g.gain.linearRampToValueAtTime(0.08, now+2+Math.random()*2);
        function modulate(){
          const t = audioCtx.currentTime;
          g.gain.linearRampToValueAtTime(0.03+Math.random()*0.08, t+3);
          setTimeout(modulate, 3000);
        }
        modulate();
        return {o,g};
      }
      // triad-ish chords
      const base = 220; // A3-ish
      gNodes = [ makePad(base), makePad(base*1.25), makePad(base*1.5) ];
    }

    // init
    fit();
    buildTextTargets();
    orchestrate();
    requestAnimationFrame(tick);
  })();
  </script>
</body>
</html>
