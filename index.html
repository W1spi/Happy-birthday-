function buildTargets(){
  const w = stage.clientWidth || window.innerWidth;
  const h = stage.clientHeight || Math.floor(window.innerHeight*0.6);
  const isPhone = window.innerWidth < 520;

  // 1) Рендерим текст на оффскрин-канвас при базовом размере
  const off = document.createElement('canvas');
  off.width  = Math.max(300, Math.floor(w));
  off.height = Math.max(160, Math.floor(h));
  const c = off.getContext('2d');

  const fsBase = Math.max(28, Math.floor(h * 0.30));
  c.clearRect(0,0,off.width,off.height);
  c.fillStyle   = '#fff';
  c.textAlign   = 'center';
  c.textBaseline= 'middle';
  c.font        = `900 ${fsBase}px system-ui, -apple-system, Segoe UI, Roboto, Arial`;
  c.fillText(TEXT, off.width/2, off.height/2);

  // 2) Семплим альфа-канал в “сырые” точки
  const img  = c.getImageData(0,0,off.width,off.height).data;
  const step = isPhone ? 4 : 3; // реже на телефоне
  const raw  = [];
  for (let y=0; y<off.height; y+=step){
    for (let x=0; x<off.width; x+=step){
      const a = img[(y*off.width + x)*4 + 3];
      if (a > 150) raw.push({x,y});
    }
  }
  if (!raw.length){ targets = []; return; }

  // 3) BBox текста
  let minX=Infinity,minY=Infinity,maxX=-Infinity,maxY=-Infinity;
  for (const p of raw){
    if (p.x<minX)minX=p.x; if (p.x>maxX)maxX=p.x;
    if (p.y<minY)minY=p.y; if (p.y>maxY)maxY=p.y;
  }
  const bw = Math.max(1, maxX-minX);
  const bh = Math.max(1, maxY-minY);
  const cx = (minX+maxX)/2, cy = (minY+maxY)/2;

  // 4) Вписываем в сцену с полями: ширина 90%, высота 62%
  const targetW = w * 0.90;
  const targetH = h * 0.62;
  const scale   = Math.min(targetW / bw, targetH / bh);

  // 5) Преобразуем в координаты сцены и слегка ограничиваем
  let pts = raw.map(p => {
    const px = (p.x - cx) * scale + w/2;
    const py = (p.y - cy) * scale + h/2;
    const x = Math.max(1, Math.min(w-2, Math.round(px)));
    const y = Math.max(1, Math.min(h-2, Math.round(py)));
    return {x,y};
  });

  // 6) Ограничиваем плотность, чтобы было читаемо
  const maxPts = isPhone ? 240 : 620;
  if (pts.length > maxPts){
    const stride = Math.max(1, Math.floor(pts.length / maxPts));
    pts = pts.filter((_, i) => i % stride === 0).slice(0, maxPts);
  }

  // 7) Перемешиваем, чтобы при формировании не было “скан-линий”
  for (let i=pts.length-1;i>0;i--){
    const j=(Math.random()*(i+1))|0; [pts[i],pts[j]]=[pts[j],pts[i]];
  }
  targets = pts;
}
